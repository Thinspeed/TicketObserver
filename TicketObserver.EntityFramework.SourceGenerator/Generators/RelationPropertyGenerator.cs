using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TicketObserver.EntityFramework.SourceGenerator.Generators;

[Generator]
public class RelationPropertyGenerator : IIncrementalGenerator
{
    private const string AttributeFileName = "RelationIdAttribute.g.cs";
    private const string Version = "1.0.0";
    private const string GeneratedFileName = "Relations.g.cs";

    private const string AttributeName = "RelationId";
    private const string AttributeFullName = $"{AttributeName}Attribute";
    private const string PropertyName = "RelationTypeName";
    
    private const string AttributeContent = $$"""
                                                    // <auto-generated/>
                                                             
                                                    namespace {{SourceGenerationHelper.AttributesNamespace}}
                                                    {
                                                        [System.AttributeUsage(System.AttributeTargets.Field)]
                                                        public sealed class {{AttributeFullName}} : System.Attribute
                                                        {
                                                            public required string {{PropertyName}} { get; init; }
                                                        }
                                                    }
                                                    """;
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            AttributeFileName,
            SourceText.From(AttributeContent, Encoding.UTF8)));
        
        IncrementalValuesProvider<FieldDeclarationSyntax> fieldDeclarations = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (s, _) => SourceGenerationHelper.IsSyntaxTargetFieldWithAttribute(s, AttributeName),
            transform: static (ctx, _) => SourceGenerationHelper.GetTargetFieldForGeneration(ctx));
        
        IncrementalValueProvider<(Compilation, ImmutableArray<FieldDeclarationSyntax>)> compilationAndFields = 
            context.CompilationProvider.Combine(fieldDeclarations.Collect());
        
        context.RegisterSourceOutput(
            compilationAndFields,
            (spc, source) => Execute(source.Item1, source.Item2, spc));
    }

    private void Execute(Compilation compilation, ImmutableArray<FieldDeclarationSyntax> fields, SourceProductionContext context)
    {
        var builder = new StringBuilder();
        builder.Append("// <auto-generated/>");

        IEnumerable<IGrouping<ClassDeclarationSyntax?, FieldDeclarationSyntax>> fieldsGroupedByClasses = 
            fields.GroupBy(x => x.Parent as ClassDeclarationSyntax);

        foreach (var group in fieldsGroupedByClasses)
        {
            if (group.Key is null) continue;
            
            SemanticModel semanticModel = compilation.GetSemanticModel(group.Key.SyntaxTree);
            ISymbol symbol = semanticModel.GetDeclaredSymbol(group.Key)!;

            builder.Append($$"""
                              
                              namespace {{symbol.ContainingNamespace?.ToDisplayString() ?? string.Empty}}
                              {
                                  partial class {{symbol.Name}}
                                  {
                              """);
            
            foreach (var field in group)
            {
                IFieldSymbol? fieldSymbol = semanticModel.GetDeclaredSymbol(field.Declaration.Variables.First()) as IFieldSymbol;
                if (fieldSymbol is null) continue;

                AttributeData? attribute = fieldSymbol
                    .GetAttributes()
                    .FirstOrDefault(x => x.AttributeClass?.Name == AttributeFullName);
                
                if (attribute is null) continue;

                string propertyTypeName = attribute
                    .NamedArguments.
                    FirstOrDefault(x => x.Key == PropertyName)
                    .Value.Value!.ToString();
                
                string idPropertyName = (fieldSymbol.Name.Length > 2 && fieldSymbol.Name.Substring(fieldSymbol.Name.Length - 2) == "Id")
                    ? System.Globalization.CultureInfo.InvariantCulture.TextInfo.ToTitleCase(fieldSymbol.Name)
                    : System.Globalization.CultureInfo.InvariantCulture.TextInfo.ToTitleCase(fieldSymbol.Name + "Id");

                if (idPropertyName[0] == '_') idPropertyName = idPropertyName.Substring(1);
                
                string propertyName = idPropertyName.Substring(0, idPropertyName.Length - 2);
                
                string idTypeName = fieldSymbol.Type.Name;

                builder.Append($$"""
                                 
                                         public {{idTypeName}} {{idPropertyName}} { get; set; }
                                         public virtual {{propertyTypeName}} {{propertyName}} { get; set; }
                                 """);
            }

            builder.Append("""
                           
                               }
                           }
                           """);
        }
        
        context.AddSource(GeneratedFileName, SourceText.From(builder.ToString(), Encoding.UTF8));
    }
}